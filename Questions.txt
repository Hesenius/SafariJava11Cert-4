Q)
Which are legal:
A) { int x; }
   { int x; }
B) class X {
     { sout(x); }
     int x;
   }
C) {
     int x;
     { int x; }
   }
D) {
     int x;
     Predicate<String> ps = x -> true;
   }
E) for (int x = 0; x < 10; x++)
     ;
   int x;

Q)
Which are legal:
A) class X {
  var x = 99;
}

B) void doStuff(var x) { }

C) void doStuff() {
  var x;
  x = 100;
}

D) void doStuff() {
  var x = 100;
}

E) void doStuff() {
  var x = { 1, 2, 3 };
}

Q) Which are legal
A)
   for (var x = 0; x < 3; x++)
     System.out.println(x);
B)
   try (var in = new FileReader("");
        var out = new FileWriter("")) {
   }
C)
   var var = "var";

D)
void doStuff() {
  var x = new int[]{ 1, 2, 3 };
}

E)
var x = 99, y = 100;

Q) Which print "true"
A) String s = "Hello";
   String t = "He";
   t += "llo";
   sout(s == t);
B) String s = "Hello";
   String t = "He";
   t += "llo";
   sout(s.equals(t));
C) StringBuilder s = new StringBuilder("Hello");
   StringBuilder t = new StringBuilder("He");
   t.append("llo");
   sout(s.equals(t));
D) List<String> ls = List.of("Fred", "Jim");
   List<String> ls2 = new ArrayList<>(ls);
   sout(ls.equals(ls2));
E) LocalDate ld = LocalDate.of(2021, 3, 29);
   LocalDate ld2 = LocalDate.of(2021, 3, 29);
   sout(ld.equals(ld2));

Q) in another jarfile:
class X {
    static String h = "Hello";
}

Which are true?
    String s1 = "Hello";
    String s2 = new StringBuilder("Hello").toString();
    String s3 = s2.intern();

A) s1 == s2
B) s2 == s3
C) s1 == s3
D) X.h == s1
E) None of the above

Q) Which are valid?
 A) int x = 99; while (x) {}
 B) int x = 99; switch (x) {}
 C) enum Day { MONDAY; }
   ...
 Day x = Day.MONDAY;
 switch (x) {
   case MONDAY:
 }
 D) enum Day { MONDAY; }
 ...
 Day x = Day.MONDAY;
 switch (x) {
   case Day.MONDAY:
 }
 E) long count = 99;
 switch (count) {}

Q) Given
  void doStuff() throws IOException {};
  void doStuff2() throws FileNotFoundException {};
And:
  void tryStuff() {
    try {
      doStuff();
      doStuff2();
    } enter code here {
      // handle both exceptions
    }
  }
What can be inserted at "enter code here" to provide handling of exceptions from both methods?
A) catch (IOException | FileNotFoundException e)
B) catch (FileNotFoundException | IOException e)
C) catch (FileNotFoundException e)
D) catch (IOException e)
E) finally

Q) Given
  class AC implements AutoCloseable {
    private String name;
    public AC(String name) { this.name = name; }
    @Override public void close() { System.out.print("Closing " + name); }
  }

  public static void main(String[] args) {
      var ac0 = new AC("zero");
      try (var ac1 = new AC("one");
          var ac2 = new AC("two");
          ac0;){}
    }
What is the result?
A) Compilation fails
B) Closing zeroClosing twoClosing one
C) Closing zeroClosing oneClosing two
D) Closing twoClosing oneClosing zero
E) Closing oneClosing twoClosing zero

Q) Given:
void doStuff(int x, int y) {}         // Method A
void doStuff(int x, long y) {}        // Method B
void doStuff(long x, int y) {}        // Method C
void doStuff(int ... x) {}            // Method D
void doStuff(Integer x, Integer y) {} // Method E

Given all five methods exist, which is invoked by this invocation?

       doStuff(1, 2);

Q) Given:
void doStuff(int x, long y) {}        // Method B
void doStuff(long x, int y) {}        // Method C
void doStuff(int ... x) {}            // Method D
void doStuff(Integer x, Integer y) {} // Method E

What is the result of this invocation?

       doStuff(1, 2);

A) Compilation fails

Q) Given:
void doStuff(int ... x) {}            // Method D
void doStuff(Integer x, Integer y) {} // Method E

What is the result of this invocation?

       doStuff(1, 2);

A) Compilation fails
B) runtime exception
C) none :)

Q) Given:
interface Int1 {
 default void doStuff() {
   System.out.println("Int1.doStuff()");
 }
}
class Cl1 implements Int1 {
 void doStuff() {
   System.out.println("Cl1.doStuff");
 }
}
What is the result of a call:
new Cl1().doStuff();

A) Compilation fails
B) RuntimeException
C) Int1.doStuff()
D) Cl1.doStuff()
E) Int1.doStuff()
   Cl1.doStuff()

Q) Given:
interface Int1 {
 default void doStuff() { System.out.println("Int1.doStuff()"); }
}
class Cl2 implements Int1 {
 public void doStuff() { System.out.println("Cl2.doStuff"); }
}
What is the result of a call:
public class Q2 {
 public static void main(String[] args) { new Cl2().doStuff(); }
}
A) Compilation fails
B) RuntimeException
C) Int1.doStuff()
D) Cl2.doStuff()
E) Int1.doStuff()
   Cl2.doStuff()

Q) Given:
interface IntA {
 default void doStuff() {  System.out.println("IntA.doStuff()"); }
}
interface IntB {
 default void doStuff() { System.out.println("IntB.doStuff()"); }
}
class ClA implements IntA, IntB {
 public void doStuff() { System.out.println("ClA.doStuff"); }
}
What is the result of a call:
public class Q3 {
 public static void main(String[] args) { new ClA().doStuff(); }
}
A) Compilation fails
B) RuntimeException
C) IntA.doStuff()
D) IntB.doStuff()
E) ClA.doStuff()